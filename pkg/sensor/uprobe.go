// Copyright 2018 Capsule8, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sensor

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/capsule8/capsule8/pkg/expression"
	"github.com/capsule8/capsule8/pkg/sys/perf"
)

// UserFunctionCallTelemetryEvent is a telemetry event generated by the
// user function call event source.
type UserFunctionCallTelemetryEvent struct {
	TelemetryEventData

	Arguments expression.FieldValueMap
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a user function call telemetry event.
func (e UserFunctionCallTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

var validUserSymbolRegex = regexp.MustCompile("^[A-Za-z_]{1}[\\w]*$")

func (s *Subscription) handleUprobe(eventid uint64, sample *perf.Sample) {
	var e UserFunctionCallTelemetryEvent
	if e.InitWithSample(s.sensor, sample) {
		e.Arguments, _ = sample.DecodeRawData()
		s.DispatchEvent(eventid, e, nil)
	}
}

// RegisterUserFunctionCallEventFilter registers a user function call event
// filter with a subscription.
func (s *Subscription) RegisterUserFunctionCallEventFilter(
	executable string,
	symbol string,
	onReturn bool,
	arguments map[string]string,
	filter *expression.Expression,
) {
	// The symbol must begin with [A-Za-z_] and contain only [A-Za-z0-9_]
	// We do not accept addresses or offsets
	if !validUserSymbolRegex.MatchString(symbol) {
		s.logStatus(
			fmt.Sprintf("User function call symbol %q is invalid", symbol))
		return
	}

	l := make([]string, 0, len(arguments))
	for k, v := range arguments {
		l = append(l, fmt.Sprintf("%s=%s", k, v))
	}
	fetchargs := strings.Join(l, " ")

	// Pass nil for filterTypes here to force the filter types to be
	// determined dynamically after the uprobe is registered with the
	// kernel.
	s.registerUprobe(executable, symbol, onReturn, fetchargs,
		s.handleUprobe, filter, true)
}
