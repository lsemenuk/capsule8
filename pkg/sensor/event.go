// Copyright 2017 Capsule8, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sensor

import (
	"crypto/sha256"
	"encoding/hex"
	"sync/atomic"
	"unsafe"

	"github.com/capsule8/capsule8/pkg/sys"
	"github.com/capsule8/capsule8/pkg/sys/perf"
)

// TelemetryEvent is an interface defining an event generated by the sensor in
// response to activity on the system that matches a subscriptions's event
// filter.
type TelemetryEvent interface {
	CommonTelemetryEventData() TelemetryEventData
}

// TelemetryEventData is an event generated by the sensor in response to activity
// on the system that matches a subscription's event filter. It contains all
// relevant information.
type TelemetryEventData struct {
	EventID        string
	SensorID       string
	MonotimeNanos  int64
	SequenceNumber uint64

	ProcessID      string
	PID            int
	TGID           int
	CPU            uint32
	HasCredentials bool
	Credentials    Cred

	Container ContainerInfo
}

// Init initializes a telemetry event with common sensor-specific fields
// correctly populated.
func (e *TelemetryEventData) Init(sensor *Sensor) {
	e.SensorID = sensor.ID
	e.MonotimeNanos = sys.CurrentMonotonicRaw() - sensor.bootMonotimeNanos
	e.SequenceNumber = atomic.AddUint64(&sensor.sequenceNumber, 1)

	var b [64 + 8 + 8]byte
	copy(b[:], ([]byte)(sensor.ID))
	*(*uint64)(unsafe.Pointer(&b[64])) = e.SequenceNumber
	*(*int64)(unsafe.Pointer(&b[72])) = e.MonotimeNanos

	hash := sha256.Sum256(b[:])
	e.EventID = hex.EncodeToString(hash[:])

	atomic.AddUint64(&sensor.Metrics.Events, 1)
}

// InitWithSampleID initializes a telemetry event using perf_event sample
// information. If the sample should be suppressed for some reason, the
// return will be false.
func (e *TelemetryEventData) InitWithSampleID(
	sensor *Sensor,
	sampleID perf.SampleID,
) bool {
	var leader, task *Task
	if pid := int(sampleID.TID); pid != 0 {
		task, leader = sensor.ProcessCache.LookupTaskAndLeader(pid)
		if leader.IsSensor() {
			return false
		}
	}

	e.Init(sensor)
	e.MonotimeNanos = int64(sampleID.Time) - sensor.bootMonotimeNanos
	e.CPU = sampleID.CPU

	if task != nil {
		e.ProcessID = task.ProcessID
		e.PID = task.PID
		e.TGID = task.TGID
		if task.Creds != nil {
			e.HasCredentials = true
			e.Credentials = *task.Creds
		}

		if i := sensor.ProcessCache.LookupTaskContainerInfo(leader); i == nil {
			e.Container.ID = task.ContainerID
		} else {
			e.Container = *i
		}
	}

	return true
}

// InitWithSample initializes a telemetry event using perf_event sample
// information. If the sample should be suppressed for some reason, the
// return will be false.
func (e *TelemetryEventData) InitWithSample(
	sensor *Sensor,
	sample *perf.Sample,
) bool {
	return e.InitWithSampleID(sensor, sample.SampleID)
}
